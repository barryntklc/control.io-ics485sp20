<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Control.io Beta</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
            //Web JS Project that implements THREE.js.
            //Literally based off of tutorial:
            //https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene

            var max_x = window.innerWidth;
            var min_x = -max_x;
            var max_y = window.innerHeight;
            var min_y = -max_y;

            var player_max_velocity = .05;
            var players = [];
            var player_radius = .07;

            var canvas_multiplier = 335;

            /** 
             * Player
             * Class that represents a Player
             */
            class Player {
                constructor(color, name, keybinds) {
                    this.prevLJ_X = 0;
                    this.prevLJ_Y = 0;
                    this.prevRJ_X = 0;
                    this.prevRJ_Y = 0;

                    this.keybinds = keybinds;
                    this.geometry = new THREE.CircleGeometry(player_radius, 32);
                    this.material = new THREE.MeshBasicMaterial({
                        color: color
                    });
                    this.player_object = new THREE.Mesh(this.geometry, this.material);
                    this.randomSpawn();                    
                };

                randomSpawn() {
                    var random_x = Math.floor(((Math.random() * Math.floor(max_x * 2)) - max_x))/canvas_multiplier;
                    var random_y = Math.floor(((Math.random() * Math.floor(max_y * 2)) - max_y))/canvas_multiplier;
                    this.player_object.position.x = random_x;
                    this.player_object.position.y = random_y;
                }

                getPlayerObject () {
                    return this.player_object;
                };

                moveUp () {
                    var player_y = this.player_object.position.y += player_max_velocity;
                    if (player_y <= max_y/canvas_multiplier) {
                        this.player_object.position.y = player_y;
                    } else {
                        this.player_object.position.y = max_y/canvas_multiplier;
                    }
                }

                moveDown () {
                    var player_y = this.player_object.position.y -= player_max_velocity;
                    if (player_y >= min_y/canvas_multiplier) {
                        this.player_object.position.y = player_y;
                    } else {
                        this.player_object.position.y = min_y/canvas_multiplier;
                    }
                }

                moveLeft () {
                    var player_x = this.player_object.position.x -= player_max_velocity;
                    if (player_x >= min_x/canvas_multiplier) {
                        this.player_object.position.x = player_x;
                    } else {
                        this.player_object.position.x = min_x/canvas_multiplier;
                    }
                }

                moveRight () {
                    var player_x = this.player_object.position.x += player_max_velocity;
                    if (player_x <= max_x/canvas_multiplier) {
                        this.player_object.position.x = player_x;
                    } else {
                        this.player_object.position.x = max_x/canvas_multiplier;
                    }
                }

                moveX (modifier) {
                    var player_x = this.player_object.position.x += (player_max_velocity * modifier);
                    this.player_object.position.x = player_x;
                    
                    //TODO Constrain x axes movement to area
                    // if (player_x <= max_x/canvas_multiplier) {
                    //     this.player_object.position.x = player_x;
                    // } else {
                    //     this.player_object.position.x = max_x/canvas_multiplier;
                    // }
                }

                moveY (modifier) {
                    var player_y = this.player_object.position.y += (player_max_velocity * modifier);
                    this.player_object.position.y = player_y;
                    
                    //TODO Constrain y axes movement to area
                    // if (player_y >= min_y/canvas_multiplier) {
                    //     this.player_object.position.y = player_y;
                    // } else {
                    //     this.player_object.position.y = min_y/canvas_multiplier;
                    // }
                }

                updatePos () {
                    if (this.UpPressed) {
                        this.moveUp();
                    }
                    if (this.DownPressed) {
                        this.moveDown();
                    }
                    if (this.LeftPressed) {
                        this.moveLeft();
                    }
                    if (this.RightPressed) {
                        this.moveRight();
                    }
                }

                keyDown (e) {
                    switch(e.code) {
                        case this.keybinds.up:
                            this.UpPressed = true;
                            break;
                        case this.keybinds.down:
                            this.DownPressed = true;
                            break;
                        case this.keybinds.left:
                            this.LeftPressed = true;
                            break;
                        case this.keybinds.right:
                            this.RightPressed = true;
                            break;
                        default:
                            break;
                    }
                }

                keyUp (e) {
                    switch(e.code) {
                        case this.keybinds.up:
                            this.UpPressed = false;
                            break;
                        case this.keybinds.down:
                            this.DownPressed = false;
                            break;
                        case this.keybinds.left:
                            this.LeftPressed = false;
                            break;
                        case this.keybinds.right:
                            this.RightPressed = false;
                            break;
                        default:
                            break;
                    }
                }
            };

            var zoom_percent = 100;
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( zoom_percent, max_x / max_y, 1, 1000 );
            // var camera = new THREE.PerspectiveCamera( zoom_percent, max_x*2 / max_y, 1, 1000 );
            camera.position.z = 5;

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( max_x, max_y );
            document.body.appendChild( renderer.domElement );

            window.addEventListener('gamepadconnected', controllerConnectedEvent);
            // window.addEventListener('resize', windowResizeEvent);
            window.addEventListener('keydown', keyDownEvent);
            window.addEventListener('keyup', keyUpEvent);

            //Literally from https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API
            /**
             * controllerConnectedEvent
             * Detects when a gamepad is connected
             */
            function controllerConnectedEvent(event) {
                console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                event.gamepad.index, event.gamepad.id,
                event.gamepad.buttons.length, event.gamepad.axes.length);
                //imagine spawning a player when they connect a gamepad though. Could make for a cool feature.
            };

            //probably should set the size proportionally
            // function windowResizeEvent() {
            //     renderer.setSize( max_x, max_y );
            // }

            function keyDownEvent(event) {
                players.forEach(function (player) {
                    player.keyDown(event);
                });
            }

            function keyUpEvent(event) {
                players.forEach(function (player) {
                    player.keyUp(event);
                });
            }

            function updatePos() {
                players.forEach(function (player) {
                    player.updatePos();
                });
            }

            function animate() {
                requestAnimationFrame(animate);

                updatePos();

                gamepad_detect();

                renderer.render(scene, camera);
            }

            function gamepad_detect() {
                if (navigator.getGamepads) {
                    var gp = navigator.getGamepads()[0];

                    if (gp.buttons[0].value > 0 || gp.buttons[0].pressed == true) {
                        console.log("AButton pressed.");
                    }
                    if (gp.buttons[1].value > 0 || gp.buttons[1].pressed == true) {
                        console.log("BButton pressed.");
                    }
                    if (gp.buttons[2].value > 0 || gp.buttons[2].pressed == true) {
                        console.log("XButton pressed.");
                    }
                    if (gp.buttons[3].value > 0 || gp.buttons[3].pressed == true) {
                        console.log("YButton pressed.");
                    }
                    if (gp.buttons[4].value > 0 || gp.buttons[4].pressed == true) {
                        console.log("LButton pressed.");
                    }
                    if (gp.buttons[5].value > 0 || gp.buttons[5].pressed == true) {
                        console.log("RButton pressed.");
                    }
                    if (gp.buttons[6].value > 0 || gp.buttons[6].pressed == true) {
                        console.log("LTrigger pressed.");
                    }
                    if (gp.buttons[7].value > 0 || gp.buttons[7].pressed == true) {
                        console.log("RTrigger pressed.");
                    }
                    if (gp.buttons[8].value > 0 || gp.buttons[8].pressed == true) {
                        console.log("BackButton pressed.");
                    }
                    if (gp.buttons[9].value > 0 || gp.buttons[9].pressed == true) {
                        console.log("StartButton pressed.");
                    }
                    if (gp.buttons[10].value > 0 || gp.buttons[10].pressed == true) {
                        console.log("LeftJoystickButton pressed.");
                    }
                    if (gp.buttons[11].value > 0 || gp.buttons[11].pressed == true) {
                        console.log("RightJoystickButton pressed.");
                    }
                    if (gp.buttons[12].value > 0 || gp.buttons[12].pressed == true) {
                        console.log("Up pressed.");
                    }
                    if (gp.buttons[13].value > 0 || gp.buttons[13].pressed == true) {
                        console.log("Down pressed.");
                    }
                    if (gp.buttons[14].value > 0 || gp.buttons[14].pressed == true) {
                        console.log("Left pressed.");
                    }
                    if (gp.buttons[15].value > 0 || gp.buttons[15].pressed == true) {
                        console.log("Right pressed.");
                    }
                    if (gp.buttons[16].value > 0 || gp.buttons[16].pressed == true) {
                        console.log("5 pressed.");
                    }

                    var currLJ_X = getAxesValue(gp.axes[0]);
                    var currLJ_Y = getAxesValue(gp.axes[1]);

                    // players[0]

                    if (!(players[0].prevLJ_X == currLJ_X)) {
                        players[0].prevLJ_X = currLJ_X;
                    }
                    if (!(players[0].prevLJ_Y == currLJ_Y)) {
                        players[0].prevLJ_Y = currLJ_Y;
                    }

                    var currRJ_X = getAxesValue(gp.axes[2]);
                    var currRJ_Y = getAxesValue(gp.axes[3]);
                    if (!(players[0].prevRJ_X == currRJ_X)) {
                        players[0].prevRJ_X = currRJ_X;
                    }
                    if (!(players[0].prevRJ_Y == currRJ_Y)) {
                        players[0].prevRJ_Y = currRJ_Y;
                    }

                    players[0].moveY(-currLJ_Y);
                    players[0].moveX(currLJ_X);
                }
            }

            // function movePlayer() {
            //     players[0].moveUp()
            // }

            //returns floats to a .05 threshold, ensuring controller idle
            function getAxesValue(float) {
                var float_val = Math.floor(float*100)/100;
                if ((float_val <= 0.05) && (float_val >= -0.05)) {
                    return 0;
                } else if ((float_val >= 0.95) && (float_val >= 1)) {
                    return 1;
                } else if ((float_val <= -0.95) && (float_val <= -1)) {
                    return -1;
                } else {
                    return float_val;
                }
            }

            function init() {
                players.push(new Player(0x4d88d5, "Player 1", {up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight"}));
                players.push(new Player(0xff0000, "Player 2", {up: "KeyW", down: "KeyS", left: "KeyA", right: "KeyD"}));
                players.push(new Player(0x009933, "Player 3", {up: "KeyI", down: "KeyK", left: "KeyJ", right: "KeyL"}));
                players.push(new Player(0xffff00, "Player 4", {up: "KeyG", down: "KeyB", left: "KeyV", right: "KeyN"}));
                
                players.forEach(function (player) {
                    scene.add(player.getPlayerObject());
                });
            };

            //initializes and animates the project
            init();
            animate();
		</script>
	</body>
</html>